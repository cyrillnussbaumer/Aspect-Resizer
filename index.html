<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smart AdSizer Lite</title>
  <!-- SmartCrop.js - loaded once from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/smartcrop/2.0.3/smartcrop.min.js"></script>
  <style>
    /* Core styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f8f9fa;
      color: #333;
      line-height: 1.5;
    }
    h1, h2, h3 { margin-top: 0; }
    h1, h2 { text-align: center; }
    button {
      background: #0d6efd;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background: #0b5ed7; }
    button:disabled { background: #6c757d; cursor: not-allowed; }
    .container { display: flex; flex-wrap: wrap; gap: 20px; }
    .panel {
      background: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .drop-area {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 25px;
      text-align: center;
      cursor: pointer;
      transition: background 0.3s;
    }
    .drop-area:hover { background: #f1f3f5; }
    input[type="number"] { 
      width: 80px;
      padding: 8px;
      margin: 5px;
    }
    input[type="text"] { 
      width: 150px;
      padding: 8px;
      margin: 5px;
    }
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
    }
    .preview-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .preview-image {
      max-width: 100%;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    img { max-width: 100%; }
    .source-info {
      text-align: center;
      font-size: 14px;
      color: #6c757d;
    }
    
    /* Collapsible section styles */
    .platform-section {
      margin-bottom: 8px;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    .platform-header {
      background: #f8f9fa;
      padding: 8px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
    }
    .platform-header:hover {
      background: #e9ecef;
    }
    .platform-content {
      padding: 8px 15px;
      display: none;
    }
    .platform-content.show {
      display: block;
    }
    
    /* Select all buttons */
    .format-controls {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 10px;
      gap: 5px;
    }
    .format-controls button {
      font-size: 12px;
      padding: 5px 10px;
      background: #6c757d;
    }
    
    /* Processing indicator */
    .loading-spinner {
      display: inline-block;
      width: 15px;
      height: 15px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 5px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Crop options */
    .crop-options {
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    
    .crop-toggle {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .crop-settings {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    
    .crop-setting-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .crop-setting-group label {
      font-size: 12px;
      color: #6c757d;
    }
    
    /* Image preview with focus point selector */
    .image-preview-container {
      position: relative;
      margin: 15px auto;
      max-width: 100%;
      overflow: hidden;
    }
    
    .image-preview-canvas {
      display: block;
      max-width: 100%;
      max-height: 400px;
      margin: 0 auto;
      border: 1px solid #dee2e6;
      cursor: crosshair;
    }
    
    .focus-point {
      position: absolute;
      width: 30px;
      height: 30px;
      background: rgba(255, 0, 0, 0.5);
      border: 2px solid red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      display: none;
    }
    
    .focus-rect {
      position: absolute;
      border: 2px dashed #ff3333;
      background: rgba(255, 51, 51, 0.1);
      pointer-events: none;
      display: none;
    }
    
    .focus-controls {
      text-align: center;
      margin-top: 10px;
    }
    
    .focus-controls button {
      font-size: 13px;
      padding: 5px 10px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container { flex-direction: column; }
    }
  </style>
</head>
<body>
  <h1>Smart AdSizer Lite</h1>
  <p style="text-align: center;">Automatically crop images to popular social media formats</p>

  <div class="container">
    <div class="panel" style="flex: 2;">
      <div id="upload-area" class="drop-area">
        <p>Click or drop an image here</p>
        <input type="file" id="file-input" accept="image/*" style="display:none;">
      </div>
      
      <div id="source-preview" style="display:none; margin-top: 20px;">
        <h2>Source Image</h2>
        <div style="text-align: center;">
          <img id="source-image" alt="Source" style="display:none;">
          
          <!-- Image Preview with Focus Point Selector -->
          <div class="image-preview-container" id="preview-container">
            <canvas id="preview-canvas" class="image-preview-canvas"></canvas>
            <div id="focus-point" class="focus-point"></div>
            <div id="focus-rect" class="focus-rect"></div>
          </div>
          
          <div class="focus-controls">
            <button id="clear-focus">Clear Focus Area</button>
            <span style="margin: 0 10px; font-size: 13px; color: #6c757d;">
              Click and drag to select focus area
            </span>
          </div>
          
          <p id="source-info" class="source-info"></p>
          <button id="change-image">Change Image</button>
        </div>
      </div>
      
      <div id="results-area" style="display:none; margin-top: 20px;">
        <h2>Results</h2>
        <div id="preview-grid" class="preview-grid"></div>
        <div style="text-align: center; margin-top: 15px;">
          <button id="download-all">Download All as ZIP</button>
        </div>
      </div>
    </div>
    
    <div class="panel" style="flex: 1;">
      <h2>Select Formats</h2>
      
      <div class="format-controls">
        <button id="select-all">Select All</button>
        <button id="clear-all">Clear All</button>
      </div>
      
      <div id="format-selector">
        <!-- Platform sections will be added here dynamically -->
      </div>
      
      <h2>Custom Size</h2>
      <div>
        <div>
          <label>Width (px): <input type="number" id="custom-width" min="1" max="3000"></label>
        </div>
        <div>
          <label>Height (px): <input type="number" id="custom-height" min="1" max="3000"></label>
        </div>
        <div>
          <label>Name: <input type="text" id="custom-name" placeholder="e.g., Twitter Post"></label>
        </div>
        <button id="add-custom">Add Custom Format</button>
      </div>
      
      <div id="custom-formats" style="margin-top: 10px; display: none;">
        <h3>Custom Formats</h3>
        <div class="checkbox-group" id="custom-formats-container"></div>
      </div>
      
      <div class="crop-options">
        <div class="crop-toggle">
          <input type="checkbox" id="use-smartcrop" checked>
          <label for="use-smartcrop">Use SmartCrop.js (Content-Aware)</label>
        </div>
        
        <div id="smartcrop-settings">
          <p style="margin: 5px 0; font-size: 13px;">SmartCrop detects faces and important content</p>
          
          <div class="crop-settings">
            <div class="crop-setting-group">
              <label for="face-weight">Face Detection</label>
              <input type="range" id="face-weight" min="0" max="1" step="0.1" value="0.9">
            </div>
            
            <div class="crop-setting-group">
              <label for="edge-weight">Edge Detection</label>
              <input type="range" id="edge-weight" min="0" max="1" step="0.1" value="0.5">
            </div>
          </div>
        </div>
        
        <div class="crop-toggle" style="margin-top: 10px;">
          <input type="checkbox" id="use-focus-area" checked>
          <label for="use-focus-area">Prioritize Selected Focus Area</label>
        </div>
      </div>
      
      <div style="margin-top: 20px;">
        <button id="process-button" disabled>Process Image</button>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let sourceImage = null;
    let selectedFormats = [];
    let customFormats = [];
    let resultImages = [];
    let focusArea = null;  // Will store the focus area coordinates
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    
    // Canvas and context for the preview
    let previewCanvas = document.getElementById('preview-canvas');
    let previewCtx = previewCanvas.getContext('2d');
    
    // Predefined formats organized by platform
    const platforms = [
      {
        id: 'facebook',
        name: 'ðŸ“˜ Facebook',
        formats: [
          { id: 'fb-profile', name: 'Profile Picture', width: 180, height: 180 },
          { id: 'fb-cover', name: 'Cover Photo', width: 820, height: 312 },
          { id: 'fb-shared', name: 'Shared Image (Feed Post)', width: 1200, height: 630 },
          { id: 'fb-event', name: 'Event Cover Photo', width: 1920, height: 1005 },
          { id: 'fb-story', name: 'Facebook Story', width: 1080, height: 1920 },
          { id: 'fb-group', name: 'Group Cover Photo', width: 1640, height: 856 },
          { id: 'fb-ad', name: 'Facebook Ad (Image)', width: 1200, height: 628 },
          { id: 'fb-carousel', name: 'Facebook Carousel Ad', width: 1080, height: 1080 }
        ]
      },
      {
        id: 'instagram',
        name: 'ðŸ“¸ Instagram',
        formats: [
          { id: 'ig-profile', name: 'Profile Picture', width: 320, height: 320 },
          { id: 'ig-square', name: 'Square Post', width: 1080, height: 1080 },
          { id: 'ig-portrait', name: 'Portrait Post', width: 1080, height: 1350 },
          { id: 'ig-landscape', name: 'Landscape Post', width: 1080, height: 566 },
          { id: 'ig-story', name: 'Instagram Story / Reels', width: 1080, height: 1920 },
          { id: 'ig-ad-square', name: 'Instagram Ad (Square)', width: 1080, height: 1080 },
          { id: 'ig-ad-portrait', name: 'Instagram Ad (Portrait)', width: 1080, height: 1350 }
        ]
      },
      {
        id: 'twitter',
        name: 'ðŸ¦ X / Twitter',
        formats: [
          { id: 'tw-profile', name: 'Profile Picture', width: 400, height: 400 },
          { id: 'tw-header', name: 'Header / Banner Image', width: 1500, height: 500 },
          { id: 'tw-single', name: 'Image in Tweet (Single)', width: 1200, height: 675 },
          { id: 'tw-multiple', name: 'Image in Tweet (Multiple)', width: 1200, height: 675 },
          { id: 'tw-card', name: 'Twitter Card Image', width: 800, height: 418 }
        ]
      },
      {
        id: 'pinterest',
        name: 'ðŸ“Œ Pinterest',
        formats: [
          { id: 'pin-profile', name: 'Profile Picture', width: 165, height: 165 },
          { id: 'pin-standard', name: 'Standard Pin', width: 1000, height: 1500 },
          { id: 'pin-square', name: 'Square Pin', width: 1000, height: 1000 },
          { id: 'pin-long', name: 'Long Pin', width: 1000, height: 2100 },
          { id: 'pin-board', name: 'Pinterest Board Cover', width: 222, height: 150 }
        ]
      },
      {
        id: 'youtube',
        name: 'ðŸ“º YouTube',
        formats: [
          { id: 'yt-profile', name: 'Profile Picture', width: 800, height: 800 },
          { id: 'yt-banner', name: 'Channel Art (Banner)', width: 2560, height: 1440 },
          { id: 'yt-thumbnail', name: 'Video Thumbnail', width: 1280, height: 720 }
        ]
      },
      {
        id: 'linkedin',
        name: 'ðŸ’¼ LinkedIn',
        formats: [
          { id: 'li-profile', name: 'Profile Picture (Personal)', width: 400, height: 400 },
          { id: 'li-banner', name: 'Profile Banner (Personal)', width: 1584, height: 396 },
          { id: 'li-company-logo', name: 'Company Logo', width: 300, height: 300 },
          { id: 'li-company-banner', name: 'Company Banner Image', width: 1128, height: 191 },
          { id: 'li-square', name: 'Image Post (Square)', width: 1200, height: 1200 },
          { id: 'li-landscape', name: 'Image Post (Landscape)', width: 1200, height: 627 },
          { id: 'li-story', name: 'LinkedIn Story', width: 1080, height: 1920 }
        ]
      },
      {
        id: 'tiktok',
        name: 'ðŸŽµ TikTok',
        formats: [
          { id: 'tt-profile', name: 'Profile Picture', width: 200, height: 200 },
          { id: 'tt-video', name: 'Video / Story Format', width: 1080, height: 1920 },
          { id: 'tt-ad', name: 'Ad Creative (Vertical)', width: 1080, height: 1920 }
        ]
      },
      {
        id: 'threads',
        name: 'ðŸ“± Threads (Meta)',
        formats: [
          { id: 'th-profile', name: 'Profile Picture', width: 320, height: 320 },
          { id: 'th-portrait', name: 'Post Image (Portrait)', width: 1080, height: 1350 },
          { id: 'th-square', name: 'Post Image (Square)', width: 1080, height: 1080 },
          { id: 'th-story', name: 'Story (via Instagram)', width: 1080, height: 1920 }
        ]
      },
      {
        id: 'snapchat',
        name: 'ðŸ“£ Snapchat',
        formats: [
          { id: 'sc-story', name: 'Snap Ad / Story', width: 1080, height: 1920 },
          { id: 'sc-geofilter', name: 'Geofilter', width: 1080, height: 2340 }
        ]
      },
      {
        id: 'general',
        name: 'ðŸ“² General / Cross-Platform',
        formats: [
          { id: 'gen-story', name: 'Story Format (Universal)', width: 1080, height: 1920 },
          { id: 'gen-square', name: 'Square Image (Universal)', width: 1080, height: 1080 },
          { id: 'gen-landscape', name: 'Landscape Format (Universal)', width: 1200, height: 628 },
          { id: 'gen-portrait', name: 'Portrait Format (Universal)', width: 1080, height: 1350 }
        ]
      }
    ];
    
    // DOM Elements
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const sourcePreview = document.getElementById('source-preview');
    const sourceImageEl = document.getElementById('source-image');
    const sourceInfoEl = document.getElementById('source-info');
    const changeImageBtn = document.getElementById('change-image');
    const formatSelector = document.getElementById('format-selector');
    const customWidthInput = document.getElementById('custom-width');
    const customHeightInput = document.getElementById('custom-height');
    const customNameInput = document.getElementById('custom-name');
    const addCustomBtn = document.getElementById('add-custom');
    const customFormatsSection = document.getElementById('custom-formats');
    const customFormatsContainer = document.getElementById('custom-formats-container');
    const processBtn = document.getElementById('process-button');
    const resultsArea = document.getElementById('results-area');
    const previewGrid = document.getElementById('preview-grid');
    const downloadAllBtn = document.getElementById('download-all');
    const selectAllBtn = document.getElementById('select-all');
    const clearAllBtn = document.getElementById('clear-all');
    const useSmartcropToggle = document.getElementById('use-smartcrop');
    const useFocusAreaToggle = document.getElementById('use-focus-area');
    const faceWeightInput = document.getElementById('face-weight');
    const edgeWeightInput = document.getElementById('edge-weight');
    const previewContainer = document.getElementById('preview-container');
    const focusPoint = document.getElementById('focus-point');
    const focusRect = document.getElementById('focus-rect');
    const clearFocusBtn = document.getElementById('clear-focus');
    
    // Build platform sections
    function buildFormatSelectors() {
      formatSelector.innerHTML = '';
      
      platforms.forEach(platform => {
        const section = document.createElement('div');
        section.className = 'platform-section';
        section.id = `platform-${platform.id}`;
        
        const header = document.createElement('div');
        header.className = 'platform-header';
        header.innerHTML = `
          <span>${platform.name}</span>
          <span class="toggle-icon">â–¶</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'platform-content';
        content.id = `${platform.id}-content`;
        
        // Platform select buttons
        const platformControls = document.createElement('div');
        platformControls.className = 'format-controls';
        platformControls.innerHTML = `
          <button class="select-platform" data-platform="${platform.id}">Select All</button>
          <button class="clear-platform" data-platform="${platform.id}">Clear All</button>
        `;
        content.appendChild(platformControls);
        
        // Add checkboxes for each format
        const checkboxGroup = document.createElement('div');
        checkboxGroup.className = 'checkbox-group';
        
        platform.formats.forEach(format => {
          const label = document.createElement('label');
          label.innerHTML = `
            <input type="checkbox" class="format-checkbox" data-platform="${platform.id}" 
                  value="${format.id}" name="format"> 
            ${format.name} (${format.width}Ã—${format.height})
          `;
          checkboxGroup.appendChild(label);
        });
        
        content.appendChild(checkboxGroup);
        
        section.appendChild(header);
        section.appendChild(content);
        formatSelector.appendChild(section);
        
        // Toggle section
        header.addEventListener('click', () => {
          content.classList.toggle('show');
          header.querySelector('.toggle-icon').textContent = 
            content.classList.contains('show') ? 'â–¼' : 'â–¶';
        });
        
        // Platform select/clear buttons
        platformControls.querySelector('.select-platform').addEventListener('click', (e) => {
          e.stopPropagation();
          const platformId = e.target.dataset.platform;
          document.querySelectorAll(`.format-checkbox[data-platform="${platformId}"]`)
            .forEach(cb => cb.checked = true);
          updateSelectedFormats();
        });
        
        platformControls.querySelector('.clear-platform').addEventListener('click', (e) => {
          e.stopPropagation();
          const platformId = e.target.dataset.platform;
          document.querySelectorAll(`.format-checkbox[data-platform="${platformId}"]`)
            .forEach(cb => cb.checked = false);
          updateSelectedFormats();
        });
      });
      
      // Auto-expand first platform
      document.querySelector('.platform-content').classList.add('show');
      document.querySelector('.platform-header .toggle-icon').textContent = 'â–¼';
      
      // Add event listeners to all checkboxes
      document.querySelectorAll('.format-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', updateSelectedFormats);
      });
    }
    
    // Event Listeners
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.style.background = '#e9ecef';
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.style.background = '';
    });
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.style.background = '';
      handleFileUpload(e.dataTransfer.files[0]);
    });
    
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length) {
        handleFileUpload(e.target.files[0]);
      }
    });
    
    changeImageBtn.addEventListener('click', () => {
      sourceImage = null;
      sourcePreview.style.display = 'none';
      uploadArea.style.display = 'block';
      updateProcessButton();
      resultsArea.style.display = 'none';
      resultImages = [];
      clearFocusArea();
    });
    
    // Clear focus area
    clearFocusBtn.addEventListener('click', clearFocusArea);
    
    // Add custom format
    addCustomBtn.addEventListener('click', () => {
      const width = parseInt(customWidthInput.value);
      const height = parseInt(customHeightInput.value);
      const name = customNameInput.value.trim() || `Custom (${width}Ã—${height})`;
      
      if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
        alert('Please enter valid dimensions');
        return;
      }
      
      const id = `custom-${Date.now()}`;
      const newFormat = { id, name, width, height };
      customFormats.push(newFormat);
      
      // Add to custom formats section
      if (customFormats.length === 1) {
        customFormatsSection.style.display = 'block';
      }
      
      // Add to UI
      const newCheckbox = document.createElement('label');
      newCheckbox.innerHTML = `
        <input type="checkbox" class="custom-format-checkbox" value="${id}" checked> 
        ${name} (${width}Ã—${height})
        <button class="remove-format" data-id="${id}" style="padding: 2px 5px; font-size: 10px; background: #dc3545;">Ã—</button>
      `;
      customFormatsContainer.appendChild(newCheckbox);
      
      // Add remove event
      newCheckbox.querySelector('.remove-format').addEventListener('click', (e) => {
        e.preventDefault();
        const formatId = e.target.dataset.id;
        customFormats = customFormats.filter(f => f.id !== formatId);
        newCheckbox.remove();
        
        if (customFormats.length === 0) {
          customFormatsSection.style.display = 'none';
        }
        updateSelectedFormats();
      });
      
      // Clear inputs
      customWidthInput.value = '';
      customHeightInput.value = '';
      customNameInput.value = '';
      
      // Update selected formats
      updateSelectedFormats();
    });
    
    // Process button
    processBtn.addEventListener('click', processImage);
    
    // Download all
    downloadAllBtn.addEventListener('click', downloadAllImages);
    
    // Select/Clear all buttons
    selectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.format-checkbox, .custom-format-checkbox')
        .forEach(cb => cb.checked = true);
      updateSelectedFormats();
    });
    
    clearAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.format-checkbox, .custom-format-checkbox')
        .forEach(cb => cb.checked = false);
      updateSelectedFormats();
    });
    
    // Preview canvas mouse events for focus point selection
    previewCanvas.addEventListener('mousedown', (e) => {
      const rect = previewCanvas.getBoundingClientRect();
      const scaleX = previewCanvas.width / rect.width;
      const scaleY = previewCanvas.height / rect.height;
      
      // Calculate mouse position relative to canvas
      dragStart.x = (e.clientX - rect.left) * scaleX;
      dragStart.y = (e.clientY - rect.top) * scaleY;
      
      isDragging = true;
      
      // Clear previous focus area
      clearFocusArea();
      
      // Show focus rectangle
      focusRect.style.display = 'block';
      focusRect.style.left = `${e.clientX - rect.left}px`;
      focusRect.style.top = `${e.clientY - rect.top}px`;
      focusRect.style.width = '0';
      focusRect.style.height = '0';
    });
    
    previewCanvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const rect = previewCanvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      // Calculate rectangle dimensions
      const startX = Math.min(currentX, dragStart.x / (previewCanvas.width / rect.width));
      const startY = Math.min(currentY, dragStart.y / (previewCanvas.height / rect.height));
      const width = Math.abs(currentX - dragStart.x / (previewCanvas.width / rect.width));
      const height = Math.abs(currentY - dragStart.y / (previewCanvas.height / rect.height));
      
      // Update focus rectangle
      focusRect.style.left = `${startX}px`;
      focusRect.style.top = `${startY}px`;
      focusRect.style.width = `${width}px`;
      focusRect.style.height = `${height}px`;
    });
    
    previewCanvas.addEventListener('mouseup', (e) => {
      if (!isDragging) return;
      
      const rect = previewCanvas.getBoundingClientRect();
      const scaleX = previewCanvas.width / rect.width;
      const scaleY = previewCanvas.height / rect.height;
      
      // Calculate mouse position relative to canvas
      const endX = (e.clientX - rect.left) * scaleX;
      const endY = (e.clientY - rect.top) * scaleY;
      
      // Calculate focus area in image coordinates
      focusArea = {
        x: Math.min(dragStart.x, endX),
        y: Math.min(dragStart.y, endY),
        width: Math.abs(endX - dragStart.x),
        height: Math.abs(endY - dragStart.y)
      };
      
      // If the area is too small, treat it as a point
      if (focusArea.width < 10 && focusArea.height < 10) {
        const centerX = focusArea.x;
        const centerY = focusArea.y;
        
        // Create a small region around the point
        focusArea = {
          x: centerX - 25,
          y: centerY - 25,
          width: 50,
          height: 50
        };
        
        // Show focus point indicator
        focusPoint.style.display = 'block';
        focusPoint.style.left = `${centerX / scaleX}px`;
        focusPoint.style.top = `${centerY / scaleY}px`;
        
        // Hide focus rectangle
        focusRect.style.display = 'none';
      } else {
        // Hide focus point, keep showing rectangle
        focusPoint.style.display = 'none';
      }
      
      isDragging = false;
    });
    
    previewCanvas.addEventListener('mouseleave', () => {
      if (isDragging) {
        isDragging = false;
      }
    });
    
    // Functions
    function clearFocusArea() {
      focusArea = null;
      focusPoint.style.display = 'none';
      focusRect.style.display = 'none';
    }
    
    function handleFileUpload(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          sourceImage = {
            element: img,
            file: file,
            src: e.target.result,
            width: img.width,
            height: img.height
          };
          
          // Set up the preview canvas
          setupPreviewCanvas(img);
          
          // Update UI
          sourceInfoEl.textContent = `${img.width} Ã— ${img.height} pixels | ${(file.size / (1024 * 1024)).toFixed(2)} MB`;
          sourcePreview.style.display = 'block';
          uploadArea.style.display = 'none';
          updateProcessButton();
          
          // Clear any existing focus area
          clearFocusArea();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
    
    function setupPreviewCanvas(img) {
      // Determine canvas size while maintaining aspect ratio
      const maxWidth = previewContainer.clientWidth;
      const maxHeight = 400;
      
      let canvasWidth = img.width;
      let canvasHeight = img.height;
      
      // Scale down if necessary
      if (canvasWidth > maxWidth) {
        const scale = maxWidth / canvasWidth;
        canvasWidth = maxWidth;
        canvasHeight = img.height * scale;
      }
      
      if (canvasHeight > maxHeight) {
        const scale = maxHeight / canvasHeight;
        canvasHeight = maxHeight;
        canvasWidth = canvasWidth * scale;
      }
      
      previewCanvas.width = canvasWidth;
      previewCanvas.height = canvasHeight;
      
      // Draw image on canvas
      previewCtx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
    }
    
    function updateSelectedFormats() {
      // Get all selected predefined formats
      const selectedPredefined = Array.from(document.querySelectorAll('.format-checkbox:checked'))
        .map(checkbox => {
          const formatId = checkbox.value;
          
          // Find the format in platforms data
          for (const platform of platforms) {
            const format = platform.formats.find(f => f.id === formatId);
            if (format) return format;
          }
          
          return null;
        })
        .filter(Boolean);
      
      // Get all selected custom formats
      const selectedCustom = Array.from(document.querySelectorAll('.custom-format-checkbox:checked'))
        .map(checkbox => {
          const formatId = checkbox.value;
          return customFormats.find(f => f.id === formatId);
        })
        .filter(Boolean);
      
      selectedFormats = [...selectedPredefined, ...selectedCustom];
      
      updateProcessButton();
    }
    
    function updateProcessButton() {
      processBtn.disabled = !sourceImage || selectedFormats.length === 0;
    }
    
    async function processImage() {
      if (!sourceImage || selectedFormats.length === 0) return;
      
      processBtn.disabled = true;
      const originalButtonText = processBtn.textContent;
      processBtn.innerHTML = '<span class="loading-spinner"></span> Processing...';
      
      resultImages = [];
      previewGrid.innerHTML = '';
      
      try {
        const useSmartcrop = useSmartcropToggle.checked;
        const useFocusArea = useFocusAreaToggle.checked && focusArea;
        const faceWeight = parseFloat(faceWeightInput.value);
        const edgeWeight = parseFloat(edgeWeightInput.value);
        
        for (const format of selectedFormats) {
          let result;
          
          if (useSmartcrop && !useFocusArea) {
            // Use SmartCrop.js alone
            result = await smartCropImage(sourceImage.element, format, { faceWeight, edgeWeight });
          } else if (useFocusArea) {
            // Use focus area with or without SmartCrop
            result = await focusAreaCropImage(sourceImage.element, format, {
              useSmartcrop, faceWeight, edgeWeight
            });
          } else {
            // Use basic center crop
            result = await basicCropImage(sourceImage.element, format);
          }
          
          resultImages.push({
            format: format,
            dataUrl: result,
            name: `${format.name} (${format.width}Ã—${format.height})`
          });
          
          // Add to preview grid
          const item = document.createElement('div');
          item.className = 'preview-item';
          item.innerHTML = `
            <p>${format.name}</p>
            <img src="${result}" alt="${format.name}" class="preview-image">
            <button class="download-btn" data-index="${resultImages.length - 1}">Download</button>
          `;
          previewGrid.appendChild(item);
          
          // Add download event
          item.querySelector('.download-btn').addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index);
            downloadImage(resultImages[index]);
          });
        }
        
        resultsArea.style.display = 'block';
      } catch (error) {
        console.error('Error processing image:', error);
        alert('An error occurred while processing the image');
      } finally {
        processBtn.disabled = false;
        processBtn.innerHTML = originalButtonText;
      }
    }
    
    // Basic center crop (as a fallback)
    function basicCropImage(img, format) {
      return new Promise(resolve => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = format.width;
        canvas.height = format.height;
        
        // Calculate aspect ratios
        const sourceRatio = img.width / img.height;
        const targetRatio = format.width / format.height;
        
        let sw, sh, sx, sy;
        
        if (sourceRatio > targetRatio) {
          // Source is wider than target
          sh = img.height;
          sw = sh * targetRatio;
          sy = 0;
          sx = (img.width - sw) / 2;
        } else {
          // Source is taller than target
          sw = img.width;
          sh = sw / targetRatio;
          sx = 0;
          sy = (img.height - sh) / 2;
        }
        
        // Draw image centered
        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, format.width, format.height);
        
        // Return data URL
        resolve(canvas.toDataURL('image/jpeg', 0.9));
      });
    }
    
    // SmartCrop.js implementation
    function smartCropImage(img, format, options = {}) {
      return new Promise((resolve, reject) => {
        // Create options for SmartCrop
        const smartcropOptions = {
          width: format.width,
          height: format.height,
          minScale: 1.0,
          ruleOfThirds: true,
          boost: [
            { name: 'face', weight: options.faceWeight || 0.9 },
            { name: 'edge', weight: options.edgeWeight || 0.5 }
          ]
        };
        
        // Use SmartCrop to analyze the image
        SmartCrop.crop(img, smartcropOptions)
          .then(result => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = format.width;
            canvas.height = format.height;
            
            const crop = result.topCrop;
            
            // Draw the cropped image
            ctx.drawImage(
              img,
              crop.x, crop.y, crop.width, crop.height,
              0, 0, format.width, format.height
            );
            
            // Return data URL
            resolve(canvas.toDataURL('image/jpeg', 0.9));
          })
          .catch(err => {
            console.error('SmartCrop error:', err);
            // Fallback to basic crop if SmartCrop fails
            resolve(basicCropImage(img, format));
          });
      });
    }
    
    // Focus area crop implementation
    function focusAreaCropImage(img, format, options = {}) {
      return new Promise(async (resolve) => {
        // Convert canvas coordinates to original image coordinates
        const scaleX = img.width / previewCanvas.width;
        const scaleY = img.height / previewCanvas.height;
        
        const imageFocusArea = {
          x: focusArea.x * scaleX,
          y: focusArea.y * scaleY,
          width: focusArea.width * scaleX,
          height: focusArea.height * scaleY,
          centerX: (focusArea.x + focusArea.width / 2) * scaleX,
          centerY: (focusArea.y + focusArea.height / 2) * scaleY
        };
        
        // Target aspect ratio
        const targetRatio = format.width / format.height;
        
        // Use SmartCrop.js with the focus area as a boost region
        if (options.useSmartcrop) {
          const smartcropOptions = {
            width: format.width,
            height: format.height,
            minScale: 1.0,
            ruleOfThirds: false,  // Disable rule of thirds when focus area is used
            boost: [
              { name: 'face', weight: options.faceWeight * 0.5 || 0.4 }, // Reduce weight of faces
              { name: 'edge', weight: options.edgeWeight * 0.5 || 0.2 }  // Reduce weight of edges
            ],
            boost: [{
              x: imageFocusArea.x,
              y: imageFocusArea.y,
              width: imageFocusArea.width,
              height: imageFocusArea.height,
              weight: 1.0 // Give highest priority to focus area
            }]
          };
          
          try {
            const result = await SmartCrop.crop(img, smartcropOptions);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = format.width;
            canvas.height = format.height;
            
            const crop = result.topCrop;
            
            // Draw the cropped image
            ctx.drawImage(
              img,
              crop.x, crop.y, crop.width, crop.height,
              0, 0, format.width, format.height
            );
            
            // Return data URL
            resolve(canvas.toDataURL('image/jpeg', 0.9));
          } catch (err) {
            console.error('SmartCrop with focus area error:', err);
            // Fallback to manual focus area crop
            resolve(manualFocusAreaCrop(img, format, imageFocusArea));
          }
        } else {
          // Manual focus area crop without SmartCrop
          resolve(manualFocusAreaCrop(img, format, imageFocusArea));
        }
      });
    }
    
    // Manual focus area crop (without SmartCrop)
    function manualFocusAreaCrop(img, format, focusArea) {
      return new Promise(resolve => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = format.width;
        canvas.height = format.height;
        
        // Calculate aspect ratios
        const sourceRatio = img.width / img.height;
        const targetRatio = format.width / format.height;
        
        // Get the center of the focus area
        const focusCenterX = focusArea.centerX;
        const focusCenterY = focusArea.centerY;
        
        let cropWidth, cropHeight, cropX, cropY;
        
        if (sourceRatio > targetRatio) {
          // Source is wider than target - crop width
          cropHeight = img.height;
          cropWidth = cropHeight * targetRatio;
          
          // Center horizontally on focus point, but don't go beyond image bounds
          cropX = Math.max(0, Math.min(img.width - cropWidth, focusCenterX - cropWidth / 2));
          cropY = 0;
        } else {
          // Source is taller than target - crop height
          cropWidth = img.width;
          cropHeight = cropWidth / targetRatio;
          
          // Center vertically on focus point, but don't go beyond image bounds
          cropX = 0;
          cropY = Math.max(0, Math.min(img.height - cropHeight, focusCenterY - cropHeight / 2));
        }
        
        // Draw image centered on focus point
        ctx.drawImage(img, cropX, cropY, cropWidth, cropHeight, 0, 0, format.width, format.height);
        
        // Return data URL
        resolve(canvas.toDataURL('image/jpeg', 0.9));
      });
    }
    
    function downloadImage(image) {
      const link = document.createElement('a');
      link.href = image.dataUrl;
      link.download = `${image.format.name.replace(/\s+/g, '-').toLowerCase()}.jpg`;
      link.click();
    }
    
    async function downloadAllImages() {
      if (resultImages.length === 0) return;
      
      if (resultImages.length === 1) {
        downloadImage(resultImages[0]);
        return;
      }
      
      // For multiple files, load JSZip dynamically
      if (typeof JSZip === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = createZip;
        document.head.appendChild(script);
      } else {
        createZip();
      }
      
      async function createZip() {
        const zip = new JSZip();
        
        for (const image of resultImages) {
          const fileName = `${image.format.name.replace(/\s+/g, '-').toLowerCase()}.jpg`;
          const base64Data = image.dataUrl.split(',')[1];
          zip.file(fileName, base64Data, { base64: true });
        }
        
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'smart-adsizer-images.zip';
        link.click();
      }
    }
    
    // Initialize the app
    buildFormatSelectors();
    updateSelectedFormats();
  </script>
</body>
</html>