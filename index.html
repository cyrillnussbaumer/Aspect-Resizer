<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smart AdSizer Lite</title>
  <!-- SmartCrop.js - loaded once from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/smartcrop/2.0.3/smartcrop.min.js"></script>
  <style>
    /* Core styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f8f9fa;
      color: #333;
      line-height: 1.5;
    }
    h1, h2, h3 { margin-top: 0; }
    h1, h2 { text-align: center; }
    button {
      background: #0d6efd;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background: #0b5ed7; }
    button:disabled { background: #6c757d; cursor: not-allowed; }
    .container { display: flex; flex-wrap: wrap; gap: 20px; }
    .panel {
      background: white;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .drop-area {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 25px;
      text-align: center;
      cursor: pointer;
      transition: background 0.3s;
    }
    .drop-area:hover { background: #f1f3f5; }
    
    /* FIXED: Number input styling */
    input.numeric-only {
      width: 80px;
      padding: 8px;
      margin: 5px;
      -moz-appearance: textfield; /* Firefox */
    }
    
    /* Hide spinner for other browsers */
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    input[type="text"] { 
      width: 150px;
      padding: 8px;
      margin: 5px;
    }
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 15px;
      max-height: 300px;
      overflow-y: auto;
    }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
    }
    .preview-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .preview-image {
      max-width: 100%;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    img { max-width: 100%; }
    .source-info {
      text-align: center;
      font-size: 14px;
      color: #6c757d;
    }
    
    /* Collapsible section styles */
    .platform-section {
      margin-bottom: 8px;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    .platform-header {
      background: #f8f9fa;
      padding: 8px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
    }
    .platform-header:hover {
      background: #e9ecef;
    }
    
    /* Improved chevron styling */
    .toggle-icon {
      color: #6c757d;
      font-size: 18px; /* Bigger chevron */
      transition: transform 0.2s ease;
      user-select: none;
      transform-origin: center; /* Center the rotation */
      display: inline-block; /* Needed for transform-origin to work properly */
    }
    
    .toggle-icon.expanded {
      transform: rotate(90deg);
    }
    .platform-content {
      padding: 8px 15px;
      display: none;
    }
    .platform-content.show {
      display: block;
    }
    
    /* Select all buttons */
    .format-controls {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 10px;
      gap: 5px;
    }
    .format-controls button {
      font-size: 12px;
      padding: 5px 10px;
      background: #6c757d;
    }
    
    /* Processing indicator */
    .loading-spinner {
      display: inline-block;
      width: 15px;
      height: 15px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 5px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Crop options */
    .crop-options {
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    
    .crop-toggle {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .crop-settings {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    
    .crop-setting-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .crop-setting-group label {
      font-size: 12px;
      color: #6c757d;
    }
    
    /* IMPROVED: Image preview with exact-fit container */
    .image-preview-container {
      position: relative;
      margin: 15px auto;
      border: 1px solid #dee2e6;
      background-color: #f1f3f5;
      display: inline-block; /* Changed: Container fits content exactly */
      overflow: visible;
    }
    
    .image-preview-canvas {
      display: block;
      max-width: 100%;
      max-height: 400px;
      cursor: crosshair;
    }
    
    .focus-point {
      position: absolute;
      width: 30px;
      height: 30px;
      background: rgba(255, 0, 0, 0.5);
      border: 2px solid red;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      display: none;
      z-index: 10; /* Added to ensure visibility */
    }
    
    .focus-rect {
      position: absolute;
      border: 2px dashed #ff3333;
      background: rgba(255, 51, 51, 0.1);
      pointer-events: none;
      display: none;
      z-index: 10; /* Added to ensure visibility */
    }
    
    .focus-controls {
      text-align: center;
      margin-top: 10px;
    }
    
    .focus-controls button {
      font-size: 13px;
      padding: 5px 10px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container { flex-direction: column; }
    }
  </style>
</head>
<body>
  <h1>Smart AdSizer Lite</h1>
  <p style="text-align: center;">Automatically crop images to popular social media formats</p>

  <div class="container">
    <div class="panel" style="flex: 2;">
      <div id="upload-area" class="drop-area">
        <p>Click or drop an image here</p>
        <input type="file" id="file-input" accept="image/*" style="display:none;">
      </div>
      
      <div id="source-preview" style="display:none; margin-top: 20px;">
        <h2>Source Image</h2>
        <div style="text-align: center;">
          <!-- Use a regular img element for the initial preview -->
          <div class="image-preview-container" id="preview-container">
            <img id="preview-image" style="display:block; max-width:100%; max-height:400px; margin:0 auto;">
            <canvas id="preview-canvas" class="image-preview-canvas" style="display:none;"></canvas>
            <div id="focus-point" class="focus-point"></div>
            <div id="focus-rect" class="focus-rect"></div>
          </div>
          
          <div class="focus-controls">
            <button id="clear-focus">Clear Focus Area</button>
            <span style="margin: 0 10px; font-size: 13px; color: #6c757d;">
              Click and drag to select focus area
            </span>
          </div>
          
          <p id="source-info" class="source-info"></p>
          <button id="change-image">Change Image</button>
        </div>
      </div>
      
      <div id="results-area" style="display:none; margin-top: 20px;">
        <h2>Results</h2>
        <div id="preview-grid" class="preview-grid"></div>
        <div style="text-align: center; margin-top: 15px;">
          <button id="download-all">Download All as ZIP</button>
        </div>
      </div>
    </div>
    
    <div class="panel" style="flex: 1;">
      <h2>Select Formats</h2>
      
      <div class="format-controls">
        <button id="select-all">Select All</button>
        <button id="clear-all">Clear All</button>
      </div>
      
      <div id="format-selector">
        <!-- Platform sections will be added here dynamically -->
      </div>
      
      <h2>Custom Size</h2>
      <div>
        <div>
          <label>Width: 
            <input type="text" class="numeric-only" id="custom-width" placeholder="px">
          </label>
        </div>
        <div>
          <label>Height: 
            <input type="text" class="numeric-only" id="custom-height" placeholder="px">
          </label>
        </div>
        <div>
          <label>Name: <input type="text" id="custom-name" placeholder="e.g., Twitter Post"></label>
        </div>
        <button id="add-custom">Add Custom Format</button>
      </div>
      
      <div id="custom-formats" style="margin-top: 10px; display: none;">
        <h3>Custom Formats</h3>
        <div class="checkbox-group" id="custom-formats-container"></div>
      </div>
      
      <div class="crop-options">
        <div class="crop-toggle">
          <input type="checkbox" id="use-smartcrop" checked>
          <label for="use-smartcrop">Use SmartCrop.js (Content-Aware)</label>
        </div>
        
        <div id="smartcrop-settings">
          <p style="margin: 5px 0; font-size: 13px;">SmartCrop uses advanced algorithms to detect interesting content</p>
        </div>
        
        <div class="crop-toggle" style="margin-top: 10px;">
          <input type="checkbox" id="use-focus-area" checked>
          <label for="use-focus-area">Prioritize Selected Focus Area</label>
        </div>
      </div>
      
      <div style="margin-top: 20px;">
        <button id="process-button" disabled>Process Image</button>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let sourceImage = null;
    let selectedFormats = [];
    let customFormats = [];
    let resultImages = [];
    let focusArea = null;  // Will store the focus area coordinates
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    
    // Canvas and context for the preview
    let previewCanvas = document.getElementById('preview-canvas');
    let previewCtx = previewCanvas.getContext('2d');
    let previewImage = document.getElementById('preview-image');
    
    // Predefined formats organized by platform
    const platforms = [
      {
        id: 'facebook',
        name: 'ðŸ“˜ Facebook',
        formats: [
          { id: 'fb-profile', name: 'Profile Picture', width: 180, height: 180 },
          { id: 'fb-cover', name: 'Cover Photo', width: 820, height: 312 },
          { id: 'fb-shared', name: 'Shared Image (Feed Post)', width: 1200, height: 630 },
          { id: 'fb-event', name: 'Event Cover Photo', width: 1920, height: 1005 },
          { id: 'fb-story', name: 'Facebook Story', width: 1080, height: 1920 },
          { id: 'fb-group', name: 'Group Cover Photo', width: 1640, height: 856 },
          { id: 'fb-ad', name: 'Facebook Ad (Image)', width: 1200, height: 628 },
          { id: 'fb-carousel', name: 'Facebook Carousel Ad', width: 1080, height: 1080 }
        ]
      },
      {
        id: 'instagram',
        name: 'ðŸ“¸ Instagram',
        formats: [
          { id: 'ig-profile', name: 'Profile Picture', width: 320, height: 320 },
          { id: 'ig-square', name: 'Square Post', width: 1080, height: 1080 },
          { id: 'ig-portrait', name: 'Portrait Post', width: 1080, height: 1350 },
          { id: 'ig-landscape', name: 'Landscape Post', width: 1080, height: 566 },
          { id: 'ig-story', name: 'Instagram Story / Reels', width: 1080, height: 1920 },
          { id: 'ig-ad-square', name: 'Instagram Ad (Square)', width: 1080, height: 1080 },
          { id: 'ig-ad-portrait', name: 'Instagram Ad (Portrait)', width: 1080, height: 1350 }
        ]
      },
      {
        id: 'twitter',
        name: 'ðŸ¦ X / Twitter',
        formats: [
          { id: 'tw-profile', name: 'Profile Picture', width: 400, height: 400 },
          { id: 'tw-header', name: 'Header / Banner Image', width: 1500, height: 500 },
          { id: 'tw-single', name: 'Image in Tweet (Single)', width: 1200, height: 675 },
          { id: 'tw-multiple', name: 'Image in Tweet (Multiple)', width: 1200, height: 675 },
          { id: 'tw-card', name: 'Twitter Card Image', width: 800, height: 418 }
        ]
      },
      {
        id: 'pinterest',
        name: 'ðŸ“Œ Pinterest',
        formats: [
          { id: 'pin-profile', name: 'Profile Picture', width: 165, height: 165 },
          { id: 'pin-standard', name: 'Standard Pin', width: 1000, height: 1500 },
          { id: 'pin-square', name: 'Square Pin', width: 1000, height: 1000 },
          { id: 'pin-long', name: 'Long Pin', width: 1000, height: 2100 },
          { id: 'pin-board', name: 'Pinterest Board Cover', width: 222, height: 150 }
        ]
      },
      {
        id: 'youtube',
        name: 'ðŸ“º YouTube',
        formats: [
          { id: 'yt-profile', name: 'Profile Picture', width: 800, height: 800 },
          { id: 'yt-banner', name: 'Channel Art (Banner)', width: 2560, height: 1440 },
          { id: 'yt-thumbnail', name: 'Video Thumbnail', width: 1280, height: 720 }
        ]
      },
      {
        id: 'linkedin',
        name: 'ðŸ’¼ LinkedIn',
        formats: [
          { id: 'li-profile', name: 'Profile Picture (Personal)', width: 400, height: 400 },
          { id: 'li-banner', name: 'Profile Banner (Personal)', width: 1584, height: 396 },
          { id: 'li-company-logo', name: 'Company Logo', width: 300, height: 300 },
          { id: 'li-company-banner', name: 'Company Banner Image', width: 1128, height: 191 },
          { id: 'li-square', name: 'Image Post (Square)', width: 1200, height: 1200 },
          { id: 'li-landscape', name: 'Image Post (Landscape)', width: 1200, height: 627 },
          { id: 'li-story', name: 'LinkedIn Story', width: 1080, height: 1920 }
        ]
      },
      {
        id: 'tiktok',
        name: 'ðŸŽµ TikTok',
        formats: [
          { id: 'tt-profile', name: 'Profile Picture', width: 200, height: 200 },
          { id: 'tt-video', name: 'Video / Story Format', width: 1080, height: 1920 },
          { id: 'tt-ad', name: 'Ad Creative (Vertical)', width: 1080, height: 1920 }
        ]
      },
      {
        id: 'threads',
        name: 'ðŸ“± Threads (Meta)',
        formats: [
          { id: 'th-profile', name: 'Profile Picture', width: 320, height: 320 },
          { id: 'th-portrait', name: 'Post Image (Portrait)', width: 1080, height: 1350 },
          { id: 'th-square', name: 'Post Image (Square)', width: 1080, height: 1080 },
          { id: 'th-story', name: 'Story (via Instagram)', width: 1080, height: 1920 }
        ]
      },
      {
        id: 'snapchat',
        name: 'ðŸ“£ Snapchat',
        formats: [
          { id: 'sc-story', name: 'Snap Ad / Story', width: 1080, height: 1920 },
          { id: 'sc-geofilter', name: 'Geofilter', width: 1080, height: 2340 }
        ]
      },
      {
        id: 'general',
        name: 'ðŸ“² General / Cross-Platform',
        formats: [
          { id: 'gen-story', name: 'Story Format (Universal)', width: 1080, height: 1920 },
          { id: 'gen-square', name: 'Square Image (Universal)', width: 1080, height: 1080 },
          { id: 'gen-landscape', name: 'Landscape Format (Universal)', width: 1200, height: 628 },
          { id: 'gen-portrait', name: 'Portrait Format (Universal)', width: 1080, height: 1350 }
        ]
      }
    ];
    
    // DOM Elements
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const sourcePreview = document.getElementById('source-preview');
    const sourceInfoEl = document.getElementById('source-info');
    const changeImageBtn = document.getElementById('change-image');
    const formatSelector = document.getElementById('format-selector');
    const customWidthInput = document.getElementById('custom-width');
    const customHeightInput = document.getElementById('custom-height');
    const customNameInput = document.getElementById('custom-name');
    const addCustomBtn = document.getElementById('add-custom');
    const customFormatsSection = document.getElementById('custom-formats');
    const customFormatsContainer = document.getElementById('custom-formats-container');
    const processBtn = document.getElementById('process-button');
    const resultsArea = document.getElementById('results-area');
    const previewGrid = document.getElementById('preview-grid');
    const downloadAllBtn = document.getElementById('download-all');
    const selectAllBtn = document.getElementById('select-all');
    const clearAllBtn = document.getElementById('clear-all');
    const useSmartcropToggle = document.getElementById('use-smartcrop');
    const useFocusAreaToggle = document.getElementById('use-focus-area');
    const previewContainer = document.getElementById('preview-container');
    const focusPoint = document.getElementById('focus-point');
    const focusRect = document.getElementById('focus-rect');
    const clearFocusBtn = document.getElementById('clear-focus');
    
    // ADDED: Make numeric inputs only accept numbers
    function setupNumericInputs() {
      // Get all numeric-only inputs
      const numericInputs = document.querySelectorAll('.numeric-only');
      
      numericInputs.forEach(input => {
        // Only allow numbers on keydown
        input.addEventListener('keydown', function(e) {
          // Allow: backspace, delete, tab, escape, enter
          if ([46, 8, 9, 27, 13].indexOf(e.keyCode) !== -1 ||
              // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
              (e.keyCode === 65 && e.ctrlKey === true) ||
              (e.keyCode === 67 && e.ctrlKey === true) ||
              (e.keyCode === 86 && e.ctrlKey === true) ||
              (e.keyCode === 88 && e.ctrlKey === true) ||
              // Allow: home, end, left, right
              (e.keyCode >= 35 && e.keyCode <= 39)) {
            // Let it happen, don't do anything
            return;
          }
          
          // Ensure that it's a number and stop the keypress if not
          if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && 
              (e.keyCode < 96 || e.keyCode > 105)) {
            e.preventDefault();
          }
        });
        
        // Clean up on paste to ensure only numbers
        input.addEventListener('paste', function(e) {
          e.preventDefault();
          const pastedText = (e.clipboardData || window.clipboardData).getData('text');
          if (/^\d*$/.test(pastedText)) {
            this.value = pastedText;
          }
        });
        
        // Filter non-numeric on input (for any events we might have missed)
        input.addEventListener('input', function() {
          this.value = this.value.replace(/[^0-9]/g, '');
        });
      });
    }
    
    // IMPROVED: Coordinate system functions for better positioning
    
    /**
     * Get selection coordinates in canvas/image space (for actual functionality)
     * This maintains the original logic for image processing
     */
    function getSelectionCoordinates(canvas, event) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      return {
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY
      };
    }
    
    /**
     * Get visual feedback coordinates relative to the canvas (simplified)
     * Now that container fits exactly, we can use canvas coordinates directly
     */
    function getVisualFeedbackCoordinates(canvas, event) {
      const rect = canvas.getBoundingClientRect();
      
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }
    
    /**
     * Convert canvas coordinates to visual coordinates (simplified)
     * Since container now fits exactly, this is much simpler
     */
    function canvasToVisualCoordinates(canvas, canvasX, canvasY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = rect.width / canvas.width;
      const scaleY = rect.height / canvas.height;
      
      return {
        x: canvasX * scaleX,
        y: canvasY * scaleY
      };
    }
    
    // Build platform sections
    function buildFormatSelectors() {
      formatSelector.innerHTML = '';
      
      platforms.forEach(platform => {
        const section = document.createElement('div');
        section.className = 'platform-section';
        section.id = `platform-${platform.id}`;
        
        const header = document.createElement('div');
        header.className = 'platform-header';
        header.innerHTML = `
          <span>${platform.name}</span>
          <span class="toggle-icon">â€º</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'platform-content';
        content.id = `${platform.id}-content`;
        
        // Platform select buttons
        const platformControls = document.createElement('div');
        platformControls.className = 'format-controls';
        platformControls.innerHTML = `
          <button class="select-platform" data-platform="${platform.id}">Select All</button>
          <button class="clear-platform" data-platform="${platform.id}">Clear All</button>
        `;
        content.appendChild(platformControls);
        
        // Add checkboxes for each format
        const checkboxGroup = document.createElement('div');
        checkboxGroup.className = 'checkbox-group';
        
        platform.formats.forEach(format => {
          const label = document.createElement('label');
          label.innerHTML = `
            <input type="checkbox" class="format-checkbox" data-platform="${platform.id}" 
                  value="${format.id}" name="format"> 
            ${format.name} (${format.width}Ã—${format.height})
          `;
          checkboxGroup.appendChild(label);
        });
        
        content.appendChild(checkboxGroup);
        
        section.appendChild(header);
        section.appendChild(content);
        formatSelector.appendChild(section);
        
        // Toggle section
        header.addEventListener('click', () => {
          const isExpanded = content.classList.contains('show');
          const toggleIcon = header.querySelector('.toggle-icon');
          
          content.classList.toggle('show');
          
          if (isExpanded) {
            toggleIcon.classList.remove('expanded');
          } else {
            toggleIcon.classList.add('expanded');
          }
        });
        
        // Platform select/clear buttons
        platformControls.querySelector('.select-platform').addEventListener('click', (e) => {
          e.stopPropagation();
          const platformId = e.target.dataset.platform;
          document.querySelectorAll(`.format-checkbox[data-platform="${platformId}"]`)
            .forEach(cb => cb.checked = true);
          updateSelectedFormats();
        });
        
        platformControls.querySelector('.clear-platform').addEventListener('click', (e) => {
          e.stopPropagation();
          const platformId = e.target.dataset.platform;
          document.querySelectorAll(`.format-checkbox[data-platform="${platformId}"]`)
            .forEach(cb => cb.checked = false);
          updateSelectedFormats();
        });
      });
      
      // Remove auto-expansion - all sections start closed
      // (Removed the code that auto-expanded first platform)
      
      // Add event listeners to all checkboxes
      document.querySelectorAll('.format-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', updateSelectedFormats);
      });
    }
    
    // Event Listeners
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.style.background = '#e9ecef';
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.style.background = '';
    });
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.style.background = '';
      handleFileUpload(e.dataTransfer.files[0]);
    });
    
    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length) {
        handleFileUpload(e.target.files[0]);
      }
    });
    
    changeImageBtn.addEventListener('click', () => {
      sourceImage = null;
      sourcePreview.style.display = 'none';
      uploadArea.style.display = 'block';
      updateProcessButton();
      resultsArea.style.display = 'none';
      resultImages = [];
      clearFocusArea();
    });
    
    // Clear focus area
    clearFocusBtn.addEventListener('click', clearFocusArea);
    
    // FIXED: Input validation for custom format
    addCustomBtn.addEventListener('click', () => {
      const widthInput = customWidthInput.value.trim();
      const heightInput = customHeightInput.value.trim();
      
      // Validate numeric input only
      if (!widthInput || !heightInput) {
        alert('Please enter values for both width and height');
        return;
      }
      
      const width = parseInt(widthInput);
      const height = parseInt(heightInput);
      const name = customNameInput.value.trim() || `Custom (${width}Ã—${height})`;
      
      if (width <= 0 || height <= 0) {
        alert('Dimensions must be greater than 0 pixels');
        return;
      }
      
      const id = `custom-${Date.now()}`;
      const newFormat = { id, name, width, height };
      customFormats.push(newFormat);
      
      // Add to custom formats section
      if (customFormats.length === 1) {
        customFormatsSection.style.display = 'block';
      }
      
      // Add to UI
      const newCheckbox = document.createElement('label');
      newCheckbox.innerHTML = `
        <input type="checkbox" class="custom-format-checkbox" value="${id}" checked> 
        ${name} (${width}Ã—${height})
        <button class="remove-format" data-id="${id}" style="padding: 2px 5px; font-size: 10px; background: #dc3545;">Ã—</button>
      `;
      customFormatsContainer.appendChild(newCheckbox);
      
      // Add remove event
      newCheckbox.querySelector('.remove-format').addEventListener('click', (e) => {
        e.preventDefault();
        const formatId = e.target.dataset.id;
        customFormats = customFormats.filter(f => f.id !== formatId);
        newCheckbox.remove();
        
        if (customFormats.length === 0) {
          customFormatsSection.style.display = 'none';
        }
        updateSelectedFormats();
      });
      
      // Clear inputs
      customWidthInput.value = '';
      customHeightInput.value = '';
      customNameInput.value = '';
      
      // Update selected formats
      updateSelectedFormats();
    });
    
    // Process button
    processBtn.addEventListener('click', processImage);
    
    // Download all
    downloadAllBtn.addEventListener('click', downloadAllImages);
    
    // Select/Clear all buttons
    selectAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.format-checkbox, .custom-format-checkbox')
        .forEach(cb => cb.checked = true);
      updateSelectedFormats();
    });
    
    clearAllBtn.addEventListener('click', () => {
      document.querySelectorAll('.format-checkbox, .custom-format-checkbox')
        .forEach(cb => cb.checked = false);
      updateSelectedFormats();
    });
    
    // IMPROVED: Image loading and canvas interaction with fixed positioning
    
    // When the image is first loaded, show it directly in an img tag
    previewImage.addEventListener('load', function() {
      // After image loads, initialize the canvas for interaction
      initializeFocusCanvas();
    });
    
    function initializeFocusCanvas() {
      if (!sourceImage) return;
      
      // Set canvas dimensions to match the actual image
      previewCanvas.width = sourceImage.width;
      previewCanvas.height = sourceImage.height;
      
      // Draw the image on the canvas
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.drawImage(sourceImage.element, 0, 0);
      
      // Switch from img to canvas for interaction
      previewImage.style.display = 'none';
      previewCanvas.style.display = 'block';
      
      // Ensure the container wraps around the image exactly
      previewContainer.style.textAlign = 'center'; // Center the container itself
      
      // Attach mouse events to canvas for focus selection
      setupCanvasInteraction();
    }
    
    // IMPROVED: Canvas interaction with fixed coordinate systems
    function setupCanvasInteraction() {
      // Preview canvas mouse events for focus point selection
      previewCanvas.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Prevent any default behaviors
        
        // Get coordinates for actual selection (unchanged original logic)
        const selectionCoords = getSelectionCoordinates(previewCanvas, e);
        dragStart.x = selectionCoords.x;
        dragStart.y = selectionCoords.y;
        
        isDragging = true;
        
        // Clear previous focus area
        clearFocusArea();
        
        // FIXED: Get accurate coordinates for visual feedback
        const visualCoords = getVisualFeedbackCoordinates(previewCanvas, e);
        
        // Show focus rectangle at correct visual position
        focusRect.style.display = 'block';
        focusRect.style.left = `${visualCoords.x}px`;
        focusRect.style.top = `${visualCoords.y}px`;
        focusRect.style.width = '0';
        focusRect.style.height = '0';
      });
      
      previewCanvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        // FIXED: Get accurate coordinates for visual feedback
        const currentVisualCoords = getVisualFeedbackCoordinates(previewCanvas, e);
        
        // Calculate start position in visual coordinates for display
        const startVisualCoords = canvasToVisualCoordinates(previewCanvas, dragStart.x, dragStart.y);
        
        // Calculate rectangle dimensions for visual feedback
        const rectLeft = Math.min(currentVisualCoords.x, startVisualCoords.x);
        const rectTop = Math.min(currentVisualCoords.y, startVisualCoords.y);
        const rectWidth = Math.abs(currentVisualCoords.x - startVisualCoords.x);
        const rectHeight = Math.abs(currentVisualCoords.y - startVisualCoords.y);
        
        // Update focus rectangle visual feedback
        focusRect.style.left = `${rectLeft}px`;
        focusRect.style.top = `${rectTop}px`;
        focusRect.style.width = `${rectWidth}px`;
        focusRect.style.height = `${rectHeight}px`;
      });
      
      previewCanvas.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        // UNCHANGED: Keep original selection logic for actual functionality
        const endCoords = getSelectionCoordinates(previewCanvas, e);
        const endX = endCoords.x;
        const endY = endCoords.y;
        
        // Calculate focus area in image coordinates (UNCHANGED)
        focusArea = {
          x: Math.min(dragStart.x, endX),
          y: Math.min(dragStart.y, endY),
          width: Math.abs(endX - dragStart.x),
          height: Math.abs(endY - dragStart.y)
        };
        
        // If the area is too small, treat it as a point (UNCHANGED logic)
        if (focusArea.width < 10 && focusArea.height < 10) {
          const centerX = focusArea.x;
          const centerY = focusArea.y;
          
          // Create a small region around the point (UNCHANGED)
          focusArea = {
            x: centerX - 25,
            y: centerY - 25,
            width: 50,
            height: 50
          };
          
          // FIXED: Accurate visual positioning of the focus point
          const visualCoords = getVisualFeedbackCoordinates(previewCanvas, e);
          
          focusPoint.style.display = 'block';
          focusPoint.style.left = `${visualCoords.x}px`;
          focusPoint.style.top = `${visualCoords.y}px`;
          
          // Hide focus rectangle
          focusRect.style.display = 'none';
        } else {
          // Hide focus point, keep showing rectangle
          focusPoint.style.display = 'none';
        }
        
        isDragging = false;
      });
      
      previewCanvas.addEventListener('mouseleave', () => {
        if (isDragging) {
          isDragging = false;
        }
      });
    }
    
    // Functions
    function clearFocusArea() {
      focusArea = null;
      focusPoint.style.display = 'none';
      focusRect.style.display = 'none';
    }
    
    // File upload handling
    function handleFileUpload(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('Please select a valid image file');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          sourceImage = {
            element: img,
            file: file,
            src: e.target.result,
            width: img.width,
            height: img.height
          };
          
          // First show the image directly using an img tag
          previewImage.src = e.target.result;
          
          // Update UI
          sourceInfoEl.textContent = `${img.width} Ã— ${img.height} pixels | ${(file.size / (1024 * 1024)).toFixed(2)} MB`;
          sourcePreview.style.display = 'block';
          uploadArea.style.display = 'none';
          updateProcessButton();
          
          // Clear any existing focus area
          clearFocusArea();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
    
    function updateSelectedFormats() {
      // Get all selected predefined formats
      const selectedPredefined = Array.from(document.querySelectorAll('.format-checkbox:checked'))
        .map(checkbox => {
          const formatId = checkbox.value;
          
          // Find the format in platforms data
          for (const platform of platforms) {
            const format = platform.formats.find(f => f.id === formatId);
            if (format) return format;
          }
          
          return null;
        })
        .filter(Boolean);
      
      // Get all selected custom formats
      const selectedCustom = Array.from(document.querySelectorAll('.custom-format-checkbox:checked'))
        .map(checkbox => {
          const formatId = checkbox.value;
          return customFormats.find(f => f.id === formatId);
        })
        .filter(Boolean);
      
      selectedFormats = [...selectedPredefined, ...selectedCustom];
      
      updateProcessButton();
    }
    
    function updateProcessButton() {
      processBtn.disabled = !sourceImage || selectedFormats.length === 0;
    }
    
    async function processImage() {
      if (!sourceImage || selectedFormats.length === 0) return;
      
      processBtn.disabled = true;
      const originalButtonText = processBtn.textContent;
      processBtn.innerHTML = '<span class="loading-spinner"></span> Processing...';
      
      resultImages = [];
      previewGrid.innerHTML = '';
      
      try {
        const useSmartcrop = useSmartcropToggle.checked;
        const useFocusArea = useFocusAreaToggle.checked && focusArea;
        
        for (const format of selectedFormats) {
          let result;
          
          if (useSmartcrop && !useFocusArea) {
            // Use SmartCrop.js alone
            result = await smartCropImage(sourceImage.element, format);
          } else if (useFocusArea) {
            // Use focus area with or without SmartCrop
            result = await focusAreaCropImage(sourceImage.element, format, {
              useSmartcrop
            });
          } else {
            // Use basic center crop
            result = await basicCropImage(sourceImage.element, format);
          }
          
          resultImages.push({
            format: format,
            dataUrl: result,
            name: `${format.name} (${format.width}Ã—${format.height})`
          });
          
          // Add to preview grid
          const item = document.createElement('div');
          item.className = 'preview-item';
          item.innerHTML = `
            <p>${format.name}</p>
            <img src="${result}" alt="${format.name}" class="preview-image">
            <button class="download-btn" data-index="${resultImages.length - 1}">Download</button>
          `;
          previewGrid.appendChild(item);
          
          // Add download event
          item.querySelector('.download-btn').addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index);
            downloadImage(resultImages[index]);
          });
        }
        
        resultsArea.style.display = 'block';
      } catch (error) {
        console.error('Error processing image:', error);
        alert('An error occurred while processing the image');
      } finally {
        processBtn.disabled = false;
        processBtn.innerHTML = originalButtonText;
      }
    }
    
    // Basic center crop (as a fallback)
    function basicCropImage(img, format) {
      return new Promise(resolve => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = format.width;
        canvas.height = format.height;
        
        // Calculate aspect ratios
        const sourceRatio = img.width / img.height;
        const targetRatio = format.width / format.height;
        
        let sw, sh, sx, sy;
        
        if (sourceRatio > targetRatio) {
          // Source is wider than target
          sh = img.height;
          sw = sh * targetRatio;
          sy = 0;
          sx = (img.width - sw) / 2;
        } else {
          // Source is taller than target
          sw = img.width;
          sh = sw / targetRatio;
          sx = 0;
          sy = (img.height - sh) / 2;
        }
        
        // Draw image centered
        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, format.width, format.height);
        
        // Return data URL
        resolve(canvas.toDataURL('image/jpeg', 0.9));
      });
    }
    
    // SmartCrop.js implementation (simplified - no fake sliders)
    function smartCropImage(img, format, options = {}) {
      return new Promise((resolve, reject) => {
        // Create options for SmartCrop
        const smartcropOptions = {
          width: format.width,
          height: format.height,
          minScale: 1.0,
          ruleOfThirds: true
          // Note: SmartCrop.js doesn't support adjustable face/edge weights
          // It uses built-in algorithms to detect interesting content
        };
        
        // Use SmartCrop to analyze the image
        SmartCrop.crop(img, smartcropOptions)
          .then(result => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = format.width;
            canvas.height = format.height;
            
            const crop = result.topCrop;
            
            // Draw the cropped image
            ctx.drawImage(
              img,
              crop.x, crop.y, crop.width, crop.height,
              0, 0, format.width, format.height
            );
            
            // Return data URL
            resolve(canvas.toDataURL('image/jpeg', 0.9));
          })
          .catch(err => {
            console.error('SmartCrop error:', err);
            // Fallback to basic crop if SmartCrop fails
            resolve(basicCropImage(img, format));
          });
      });
    }
    
    // Focus area crop implementation
    function focusAreaCropImage(img, format, options = {}) {
      return new Promise(async (resolve) => {
        // Convert canvas coordinates to original image coordinates
        const scaleX = img.width / previewCanvas.width;
        const scaleY = img.height / previewCanvas.height;
        
        const imageFocusArea = {
          x: focusArea.x * scaleX,
          y: focusArea.y * scaleY,
          width: focusArea.width * scaleX,
          height: focusArea.height * scaleY,
          centerX: (focusArea.x + focusArea.width / 2) * scaleX,
          centerY: (focusArea.y + focusArea.height / 2) * scaleY
        };
        
        // Target aspect ratio
        const targetRatio = format.width / format.height;
        
        // Use SmartCrop.js with the focus area as a boost region
        if (options.useSmartcrop) {
          const smartcropOptions = {
            width: format.width,
            height: format.height,
            minScale: 1.0,
            ruleOfThirds: false,  // Disable rule of thirds when focus area is used
            boost: [
              {
                x: imageFocusArea.x,
                y: imageFocusArea.y,
                width: imageFocusArea.width,
                height: imageFocusArea.height,
                weight: 1.0 // Give highest priority to focus area
              }
            ]
          };
          
          try {
            const result = await SmartCrop.crop(img, smartcropOptions);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = format.width;
            canvas.height = format.height;
            
            const crop = result.topCrop;
            
            // Draw the cropped image
            ctx.drawImage(
              img,
              crop.x, crop.y, crop.width, crop.height,
              0, 0, format.width, format.height
            );
            
            // Return data URL
            resolve(canvas.toDataURL('image/jpeg', 0.9));
          } catch (err) {
            console.error('SmartCrop with focus area error:', err);
            // Fallback to manual focus area crop
            resolve(manualFocusAreaCrop(img, format, imageFocusArea));
          }
        } else {
          // Manual focus area crop without SmartCrop
          resolve(manualFocusAreaCrop(img, format, imageFocusArea));
        }
      });
    }
    
    // Manual focus area crop (without SmartCrop)
    function manualFocusAreaCrop(img, format, focusArea) {
      return new Promise(resolve => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = format.width;
        canvas.height = format.height;
        
        // Calculate aspect ratios
        const sourceRatio = img.width / img.height;
        const targetRatio = format.width / format.height;
        
        // Get the center of the focus area
        const focusCenterX = focusArea.centerX;
        const focusCenterY = focusArea.centerY;
        
        let cropWidth, cropHeight, cropX, cropY;
        
        if (sourceRatio > targetRatio) {
          // Source is wider than target - crop width
          cropHeight = img.height;
          cropWidth = cropHeight * targetRatio;
          
          // Center horizontally on focus point, but don't go beyond image bounds
          cropX = Math.max(0, Math.min(img.width - cropWidth, focusCenterX - cropWidth / 2));
          cropY = 0;
        } else {
          // Source is taller than target - crop height
          cropWidth = img.width;
          cropHeight = cropWidth / targetRatio;
          
          // Center vertically on focus point, but don't go beyond image bounds
          cropX = 0;
          cropY = Math.max(0, Math.min(img.height - cropHeight, focusCenterY - cropHeight / 2));
        }
        
        // Draw image centered on focus point
        ctx.drawImage(img, cropX, cropY, cropWidth, cropHeight, 0, 0, format.width, format.height);
        
        // Return data URL
        resolve(canvas.toDataURL('image/jpeg', 0.9));
      });
    }
    
    function downloadImage(image) {
      const link = document.createElement('a');
      link.href = image.dataUrl;
      link.download = `${image.format.name.replace(/\s+/g, '-').toLowerCase()}.jpg`;
      link.click();
    }
    
    async function downloadAllImages() {
      if (resultImages.length === 0) return;
      
      if (resultImages.length === 1) {
        downloadImage(resultImages[0]);
        return;
      }
      
      // For multiple files, load JSZip dynamically
      if (typeof JSZip === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = createZip;
        document.head.appendChild(script);
      } else {
        createZip();
      }
      
      async function createZip() {
        const zip = new JSZip();
        
        for (const image of resultImages) {
          const fileName = `${image.format.name.replace(/\s+/g, '-').toLowerCase()}.jpg`;
          const base64Data = image.dataUrl.split(',')[1];
          zip.file(fileName, base64Data, { base64: true });
        }
        
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'smart-adsizer-images.zip';
        link.click();
      }
    }
    
    // Initialize the app
    buildFormatSelectors();
    updateSelectedFormats();
    setupNumericInputs(); // ADDED: Initialize numeric input restrictions
  </script>
</body>
</html>